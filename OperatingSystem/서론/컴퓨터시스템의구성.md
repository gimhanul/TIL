## 1-2. Computer-System Organization

![](https://velog.velcdn.com/images%2Fwilko97%2Fpost%2F8aed44bd-a2b8-4e35-b9a2-abbe6f6cd2c9%2Fimage.png)

컴퓨터 시스템은 하나 이상의 CPU와 구성 요소와 공유 메모리 사이의 액세스를 제공하는 공통 **버스**를 통해 연결된 여러 장치 컨트롤러로 구성됨.

장치 컨트롤러는 일부 로컬 버퍼 저장소와 특수 목적 레지스터 집합을 유지, 관리함. 장치 컨트롤러는 제어하는 주변 장치와 로컬 버퍼 저장소 간에 데이터를 이동함.

각 장치 컨트롤러마다 **장치 드라이버**가 있음. 이는 장치 컨트롤러의 작동을 잘 알고 있고 나머지 운영체제에 장치에 대한 일관된 인터페이스를 제공함.

CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁함. 공유 메모리를 질서 있게 액세스하기 위해 메모리 컨트롤러는 메모리에 대한 액세스를 동기화함.

<br>

### 1-2-1. 인터럽트 Interrupts


**I/O 작업 프로세스**

1. 장치 드라이버는 장치 컨트롤러의 적절한 레지스터에 값을 적재함.
2. 장치 컨트롤러는 이러한 레지스터의 내용을 검사하여 수행할 작업을 결정함. 
3. 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송을 시작함. 
4. 데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료되었음을 알림.
5. 장치 드라이버는 [읽기 요청 - 데이터 또는 데이터에 대한 포인터를 반환 / 다른 작업 - 상태 정보를 반환]하며 운영체제의 다른 부분에 제어를 넘김.

이때, 컨트롤러는 장치 드라이버에게 작업을 완료했다는 사실을 알리는 것이 **인터럽트**임.

<br>

#### 1-2-1-1. Overview

인터럽트는 다른 많은 목적으로도 사용되며 운영체제와 하드웨어 상호 작용 방식의 핵심 부분임.

![](https://velog.velcdn.com/images%2Fwilko97%2Fpost%2Faeed03d1-9a02-4550-8404-5796dfa716d0%2Fimage.png)

**CPU가 인터럽트 될 때**

1. CPU는 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮김.
    > 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지고 있음. 
2. 인터럽트 서비스 루틴이 실행됨.
3. 서비스 루틴 실행 완료시 인터럽트 되었던 연산을 재개함.

<br>

**인터럽트 벡터**

인터럽트는 매우 빈번하게 발생하기 때문에 빠르게 처리되어야 함. **필요한 속도를 제공하기 위해 인터럽트 루틴에 대해 포인터들의 테이블을 대신 이용할 수 있음.** 이 경우 중간 루틴을 둘 필요 없이, 테이블을 통해 간접적으로 인터럽트 루틴을 호출될 수 있음.
인터럽트가 요청되면, 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해 이 주소의 배열, 즉 **인터럽트 벡터**가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인됨.

<br>

**복원**

인터럽트 구조는 또한 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있음. 인터럽트를 서비스한 후, 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하고, 인터럽트에 ㅡ이해 중단되었던 연산이 인터럽트가 발생되지 않았던 것처럼 다시 시작됨.

<br>

#### 1-2-1-2. Implementation

![](https://velog.velcdn.com/images%2Fwilko97%2Fpost%2Ff47f164a-4584-4d66-9d78-19bca8873008%2Fimage.png)

**기본 인터럽트 매커니즘**

1. CPU가 컨트롤러가 **인터럽트 요청 라인 Interrupt Request Line**에 신호를 보낸 것을 감지함.
   > CPU 하드웨어에 존재하는 선으로, 하나의 명령어의 실행을 완료할 때마다 CPU가 이 선을 감지함.
2. 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용하여 **인터럽트 핸들러 루틴 Interrupt handler routine**으로 점프함.
3. 해당 인덱스와 관련된 주소에서 실행을 시작함.
4. 인터럽트 처리기는 작업 중에 변경될 상태를 저장하고, 원인을 확인하고, 처리를 수행하고, 상태를 복원하고, CPU를 인터럽트 전 실행상태를 되돌림.

<br>

**용어 정리**

1. 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를 **발생 raise** 시킴.
2. CPU는 인터럽트를 **포착 catch** 함.
3. 인터럽트를 인터럽트 핸들러로 **디스패치 dispatch** 함.
4. 핸들러는 장치를 서비스하여 인터럽트를 **지움 clear**.

<br>

**정교한 인터럽트 처리 기능**

- 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 함.
- 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치할 방법이 필요함.
- 운영체제가 우선순위에 따라 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 다단계 인터럽트가 필요함.

이 세 가지 기능은 CPU 및 **인터럽트 컨트롤러 하드웨어**에 의해 제공됨.

대부분의 CPU에는 두 개의 인터럽트 요청 라인이 있음.

- **마스크 불가능 인터럽트 nonmaskable interrupt** : 복구할 수 없는 메모리 오류와 같은 이벤트를 위해 예약됨.
- **마스킹 가능 maskable** : 인터럽트 되어서는 안 되는 중요한 명령 시퀀스를 실행하기 전에 CPU에 의해 꺼질 수 있음. 장치 컨트롤러가 서비스를 요청하기 위해 사용됨.

<br>

**인터럽트 체인**

실제로 컴퓨터에는 인터럽트 벡터의 주소 개수보다 많은 장치가 있음. 이 문제를 해결하기 위해 인터럽트 체인을 사용함.

1. 인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리킴.
2. 인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출됨.

> 큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치하는 비효율성의 절충안임.

<br>

**인터럽트 우선순위 레벨 interrupt priority level**

레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트의 처리를 연기하며, 우선순위가 높은 인터럽트가 우선순위가 낮은 인터럽트의 실행을 선점할 수 있음.

<br>

**요약**

- 인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용됨. 
- 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트가 발생함.
- 가장 긴급한 작업을 먼저 수행하기 위해 인터럽트 우선순위 시스템을 사용함. 
- 인터럽트는 시간에 민감한 처리에 빈번하게 사용되므로 시스템 성능을 좋게 하려면 효율적인 인터럽트 처리가 필요함.

<br>

<br>

### 1-2-2. 저장장치 구조 Storage Structure

CPU는 메모리에서만 명령을 적재할 수 있으므로 실행하려면 프로그램을 먼저 메모리에 적재해야 함.
모든 형태의 메모리는 바이트의 배열을 제공하며 각 바이트는 자신의 주소를 가지고 있음.

**상호 작용**

- 적재 load : 메인 메모리로부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것.
- 저장 store : 레지스터의 내용을 메인 메모리로 옮기는 것.
- 그외 : CPU는 프로그램 카운터에 저장된 위치부터 실행하기 위해 메인 메모리에서 명령을 자동으로 적재함.

<br>

**명령-실행 사이클**

1. 메모리로부터 명령을 인출한다.
2. 그 명령을 **명령 레지스터 instruction register** 에 저장함.
3. 명령을 해독함.
4. 이는 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발할 수 있음.
5. 피연산자에 대해 명령을 실행한 후에 결과가 다시 메모리에 저장될 수 있음.

> 메모리 장치는 단지 일련의 메모리 주소만을 인식함. 메모리는 이들 주소가 어떻게 생성되었는지 알지 못하며, 무엇인지도 알지 못함.
>> 그러므로 우리는 메모리 주소가 프로그램에 의해 **어떻게** 생성되었는지 무시할 수 있음.

<br>

**저장 장치 구조**

![](https://velog.velcdn.com/images%2Fwilko97%2Fpost%2Fabcd6d8c-7c6a-4150-aab7-72eec573088d%2Fimage.png)

- 휘발성 저장장치 : 전원을 꺼지면 내용이 날아감.
- 비휘발성 저장장치 : 전원이 꺼졌을 때 내용을 유지함. 이를 **NVS**라고 함.
  - 기계적 : HDD, 광 디스크, 홀로그램 저장장치, 자기 테이프 등
  - 전기적 : 플래시 메모리, FRAM, NRAM, SSD. **NVM**이라고 함.
  > |-|기계적|전기적|
  > |---|---|---|
  > |용량|큼|적음|
  > |속도|-|빠름|
  > |가격|쌈|비쌈|

<br>

**저장장치 시스템의 설계**

모든 요소의 균형을 맞추어야 함.

캐시는 두 구성요소 간에 엑세스 시간이나 전송 속도의 차이가 큰 경우 성능을 향상하기 위해 설치할 수 있음.

<br>

<br>

### 1-2-3. 입출력 구조 I/O Structure

**직접 메모리 액세스 DMA**

![](https://velog.velcdn.com/images%2Fwilko97%2Fpost%2F1f587de0-8031-41fa-9bb7-32de360e2a69%2Fimage.png)

인터럽트 구동 I/O의 형태는 소량의 데이터를 이동하는 데는 좋지만 NVS I/O와 같은 대량 데이터 이동에 사용될 때 높은 오버헤드를 유발할 수 있음.
이 문제를 해결하기 위해 **직접 메모리 액세스 DMA**를 사용함.

1. 장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅함.
2. 장치 제어기는 CPU의 개입 없이 메모리로부터 자신의 버퍼 장치 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송함.
3. 블록 전송이 완료될 때마다 인터럽트가 발생함.
> 장치 컨트롤러가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있음.
